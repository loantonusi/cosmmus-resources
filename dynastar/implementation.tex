%!TEX root =  main.tex
\section{Implementation}
\label{sec:implementation}

In this section, we describe \libname{}, a library that implements both \ssmr{}, \dssmr{} and \dynastar{}.
We also present \appname{}, a scalable social network application built with \libname{}. \libname\ and \appname\ were both implemented in Java.

\subsection{\libname}

\libname{} implements functionalities of static and dynamic mapping, and supports centralized and decentralized partitioning schemes. 
There are three classes that the developer (i.e., application designer) must extend to implement a replicated service with \libname{}: PRObject, 
PartitionStateMachine, OracleStateMachine.

The \emph{PRObject class} represents any kind of data item that is part of the service state. The state is partially replicated (i.e., 
objects are distributed among partitions). Therefore, when executing a command, a 
replica might not have local access to some of the objects involved in the execution of the command. The developer informs \libname{} which 
object classes are partially replicated by extending the PRObject class. Each object of such a class is stored locally or remotely, but 
the application code is agnostic to the location of an object. All calls to methods of such objects are intercepted by \libname{}, transparently to the developer. 

The \emph{PartitionStateMachine class} represents logic of the server proxy. The application server class must extend the 
PartitionStateMachine class. To execute commands, the developer must provide an implementation for the method executeCommand(Command). The code 
for such a method is agnostic to the existence of partitions. In other words, developer programs for classical state machine replication (i.e., full replication). \libname{} is responsible for handling all communication between partitions 
and oracle transparently. Objects that are involved in application's command will be available to the partition at the time it is accessed by the partitions. To start the server, method runStateMachine() is called. Method createObject() also needs to be implemented, where the 
developer defines how new state objects are loaded or created.


The \emph{OracleStateMachine class} defines the oracle, which is deployed as a partition. 
Because the oracle is in charge of moving the PRObjects to the appropriate 
partitions, it requires a partitioner that will provide for each object a desired location. A default partitioner is implemented using METIS, a state-of-the-art graph partitioner, but any algorithm that takes as input a graph and outputs a mapping of objects to partitions is a valid
partitioner.
The workload graph is built by aggregating hints about the objects' access patterns, and the mapping it returns indicates the ideal partition for each object. Since the partitioner is executed in every oracle replica,
its output should be deterministic so all the replicas transition to the same state after the partitioning. 
The developer can override the default algorithm to partition the graph and the oracle is agnostic to its internal behavior.
By default the OracleStateMachine calls for the coordination of a partitioning at the beginning of the execution, this can be
changed by the developer to fit the application logic. For instance, the partitioning can be triggered to 
happen when a partition is overloaded.

Notice that the oracle does not stop the system's progress while doing the partitioning, the partitioner algorithm can
 run in a different thread or computer, offloading the oracle. The oracle gets an incremental \emph{id} for the partitioning, 
 so all the replicas can execute it at the same moment, when all receive the signal to execute the partitioning, 
 even in the presence of simultaneous repartitionings.

\subsection{\appname}
\label{sec:imp:\appname}
We implemented \appname\ on top of \libname, which provides a similar API as Twitter. In Twitter, among other things
users can follow, unfollow, post and read other's tweets according to whom the user is following, users in Twitter are
constrained to post 140-character messages, those are the messages we implemented in \appname.

Given that users in social networks spend most of the time reading (i.e.: performing getTimeline) than any other operation 
\cite{facebookTAO}, we optimised \appname\ for getTimeline being always a single partition command, so when a
user request a timeline, all messages are going to be available on the partition that the request was sent to.
Because of this designing choices, moves in objects can only happen when an user issues a post, follow or unfollow
command, follow and unfollow commands can touch at most two partitions, while the post can move the objects from
one or more partitions.

To execute a post command, the \appname\ client needs to access all user's followers, so
we can ensure linearizability in case of users following/unfollowing in-between of a command execution, if such
case happens, the server sends the list of followers that should be included in the next command,
then the \appname\ server proceeds to the next command.

%
%State partitioning in \appname\ is based on users' interest. A function $f(uid)$ returns the partition that user with id $uid$ should belong to, based on the user's interest. Function $f$ is implemented in method getObjectPlacement(User) of class \appname{}Oracle, which extends OracleStateMachine (class User extends PRObject). Taking into account that a typical user probably spends more time reading messages (i.e., issuing getTimeline) than writing them (i.e., issuing post), we decided to optimize getTimeline to be single-partition. This means that, when a user requests his or her timeline, all messages should be available in the partition that stores that user's data, in the form of a materialized timeline (similarly to a materialized view in a database). To make this possible, whenever a post request is executed, the message is inserted into the materialized timeline of all users that follow the one that is posting. Also, when a user starts following another user, the messages of the followed user are inserted into the follower's materialized timeline as part of the command execution; likewise, they are removed when a user stops following another user. Because of this design decision, every getTimeline request accesses only one partition, follow and unfollow requests access objects on at most two partitions, and post requests access up to all partitions. The \appname{} client does not need any knowledge about partitions, since it uses method sendAccessCommand(command) of the \dssmr{} client proxy to issue its commands.

%One detail about the post request is that it needs access to all users that follow the user issuing the post.
%Thus the list of follower need to be attached in the post command. However, the (Chirper) client cannot know for sure who follows the user: it keeps a cache of followers, but such cache can become stale if a different user starts following the poster.
%To ensure linearizability when executing a post request, the \appname\ server overrides the extractObject(command) method to check if all followers that will be accessed by the command are available in the local partition (i.e., the partition of the server executing the post command).
%If this is the case, the request is executed.
%Otherwise, the server sends a $retry(\gamma)$ message, where $\gamma$ is the complete set of followers of the user who was posting.
%Then, the \appname\ server proceeds to the next command.
%Upon receiving the $retry(\gamma)$ message, the client proxy tries to move all users in $\gamma$ to the same partition before retrying to execute the post command.
