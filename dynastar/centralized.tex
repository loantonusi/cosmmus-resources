%!TEX root =  main.tex
\section{\dynastar: dynamic and quasi-optimum state partitioning}
%\section{\dynastar: dynamic partitioning for scalable state machine replication}
%\section{The centralized partitioning scheme}

%If the system can be modelled as a graph, as described in the previous session, we can take advantage of algorithms that perform graph partitioning to optimise the state partitioning of \ssmr\  while using concepts from \dssmr. The problem of graph partitioning is well stablished and despite being NP-Complete \ref{NPC_GraphPartition}, several approximation algorithms exist. First we define what graph partitioning is and how it can analysed to our needs, next we explore possibilities that are easily obtainable when applying the same graph's reasoning.

\subsection{Overview}
%\subsection{State partitioning as a graph problem}

We represent a service workload as a graph $G = (V, E)$, where vertices are state objects and an edges are operations.
There is an edge connecting two objects in the graph if a client can issue a command that accesses the objects. 




\subsection{The \dynastar protocol}

\input{algorithm_oracle_partition}

\begin{figure*}
\begin{minipage}[b]{1\linewidth} % A minipage that covers the whole width of the page
\centering
      \includegraphics[width=1.0\linewidth]{figures/new-scheme}
\end{minipage}
\caption{How commands are treated in case of a repartitioning in the oracle.}
\label{fig:oracle_repartition}
\end{figure*}

%\begin{figure*}
%\begin{minipage}[b]{1\linewidth} % A minipage that covers the whole width of the page
%\centering
%      \includegraphics[width=1.0\linewidth]{figures/repartitioning}
%\end{minipage}
%\caption{How commands are treated in case of a repartitioning in the oracle.}
%\label{fig:oracle_repartition}
%\end{figure*}



\input{correctness}




