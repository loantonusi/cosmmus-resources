%!TEX root =  main.tex
\section{\dynastar: dynamic and quasi-optimum state partitioning}
%\section{\dynastar: dynamic partitioning for scalable state machine replication}
%\section{The centralized partitioning scheme}

%If the system can be modeled as a graph, as described in the previous session, we can take advantage of algorithms that perform graph partitioning to optimise the state partitioning of \ssmr\  while using concepts from \dssmr. The problem of graph partitioning is well stablished and despite being NP-Complete \ref{NPC_GraphPartition}, several approximation algorithms exist. First we define what graph partitioning is and how it can analyzed to our needs, next we explore possibilities that are easily obtainable when applying the same graph's reasoning.

\subsection{Overview}
%\subsection{State partitioning as a graph problem}

\dynastar extends the dynamic partitioning scheme proposed by Long et al.~\cite{hoang2016} to cope with workloads that exhibit weak locality, that is, workloads that cannot be perfectly partitioned.
The key insights of \dynastar are to model the workload dynamically and use graph partitioning techniques to optimally relocate application state on-the-fly.
\begin{itemize}
\item \emph{Dynamic workload modeling.}
\dynastar represents a service workload as a graph $G = (V, E)$, where vertices are state variables and an edges are commands.
There is an edge connecting two variables in the graph if a client can issue a command that accesses the objects. 

\item Data relocation on-the-fly.
\end{itemize}




\subsection{The \dynastar protocol}

Algorithms~\ref{alg:client_proxy}, \ref{alg:server_proxy}, and \ref{alg:oracle_proxy} describe in detail how client, server and oracle processes execute, respectively.
For brevity, we omit the delete command since the coordination involved in the execution of a create and of a delete commands are analogous. 
Moreover, in the discussion in this section, every command involves the oracle.
In the next section, we explain how clients can use a caching technique to avoid using the oracle in the execution of most commands.

\begin{figure*}
\begin{minipage}[b]{1\linewidth} % A minipage that covers the whole width of the page
\centering
      \includegraphics[width=0.9\linewidth]{figures/dynastar}
\end{minipage}
\caption{The execution of a create command and a read command in \dynastar.}
\label{fig:oracle_repartition}
\end{figure*}

%When issuing a command, the application simply forwards the command to the client proxy and waits for the reply.
%Consulting the oracle and multicasting the command to different partitions is done internally by the proxy at the client.
%Every server proxy at a server in $\ssm_i$ has only partial knowledge of the partitioning: it knows only which variables belong to $\ppm_i$.
%The oracle proxy has knowledge of every $\ppm \in \Psi$.
%To maintain such a global knowledge, the oracle must \amdel{} every command that creates, moves, or deletes variables.
%(In Section~\ref{sec:optm}, we introduce a caching mechanism to prevent the oracle from becoming a performance bottleneck.)

%\clearpage
\input{algorithm_client_proxy}
\input{algorithm_server_proxy}
\input{algorithm_oracle_proxy}



\subsubsection{The client process} 

To execute a command, the client atomically multicasts the command to the oracle in a consult message to find out the partitions involved.
The oracle replies with a prophecy, which may already tell the client that the command cannot be executed (e.g., it needs a variable that does not exist, it tries to create a variable that already exists).
If the command can be executed, the client receives a prophecy containing a tuple $(dests, sync)$, where $dests$ is a set of the partitions the command must be atomically multicast to for execution, and $sync$ is a flag that tells the client whether it must coordinate with a partition before atomically multicasting the command.
This happens if the oracle requests variables to be moved to a single destination partition, in which case the client must wait for the destination partition to receive the variables.

After the client atomically multicasts the command to the destination partition, it waits for a response from the servers in the partition.
The client must retry the command if the partition cannot execute the command.
This happens if some of the variables needed by the command were moved to another partition due to other commands. 
To ensure that a command is eventually executed, after retrying a few times, the client falls back \ssmr{}, multicasting the command to all partitions (and the oracle, in case of a create or delete command).

\subsubsection{The server process} 

When a server delivers a command for execution, it first checks that all variables accessed by the command are stored locally, in which case the command is executed and the response is sent back to the client (Task 1 in Algorithm~\ref{alg:server_proxy}).
If one or more variables are not stored at the partition, the server returns a message to the client to retry the operation.
This happens if some variables have been moved to another partition due to another command. 

Upon delivering a message to move variables (Task 2), a server in the source partition reliably multicasts all the needed variables stored locally to the destination partition (possibly none, if these variables have already been moved).
Servers in the destination partition simply wait for a message from each source partition.

When a server delivers a message to create a variable (and similarly to delete an existing variable), it coordinates with the oracle (Task 3).
The exchange of signals between the partition where the variable will be created and the oracle ensures that interleaved executions between create and delete commands will not lead to violations of linearizability (i.e., this is essentially the execution of a multi-partition command involving the oracle and a partition~\cite{bezerra2014ssmr}).

\subsubsection{The oracle} 

When the oracle delivers a consult request (Task 1 in Algorithm~\ref{alg:oracle_proxy}), it distinguishes between two cases.
\begin{itemize}
\item If the command is to create a variable $v$, the oracle checks that the $v$ does not already exist, in which case the oracle determines the destination partition of $v$ and returns a response to the client.
In the case of a create, the oracle chooses a random partition for the new variable.
\item If the command is not a create, the oracle first checks that all variables involved in the command exist.
If the variables exist and they are all in a single partition, the oracle returns to the client a prophecy with the partition the command must be atomically multicast to for execution.
If the variables accessed by the command are distributed in multiple partitions, the oracle determines the destination partition and atomically multicasts a move command to all such partitions and to the destination partition.
\end{itemize}

The oracle executes a create command (Task 2) by updating its partition information and coordinating with the destination partition of the variable.
This is done to avoid interleaved executions with other commands, which could lead to consistency violations. 
To execute a move command (Task 3), the oracle simply updates its local information about source and destination partitions.
In the case of a move command, the oracle does not coordinate with the involved partitions.
This is not necessary because a move cannot interleave its execution with a create and interleaved executions with other move commands simply result in retries by the clients.

The oracle also keeps track of the workload graph, periodically computes the ``ideal" partitioning of the graph, and determines the destination partition for move operations.
To maintain the workload graph (Task 5), the oracle receives hints with variables (i.e., vertices in the graph) and executed commands (i.e., edges in the graph).
These hints can be submitted by the clients (e.g., after the execution of a command), or by the partitions, which collect data upon executing commands and periodically inform the oracle.
In our social network application, clients inform the oracle upon submitting ``structural operations" on the social graph, that is, operations that change the  graph (i.e., follow and unfollow requests).

To ensure that the ideal partitioning periodically computed by the oracle replicas is deterministic (Task 6), each replica triggers the partitioning upon delivering a constant number of hints.
Moreover, the algorithm used to compute the partitioning of the graph must be also deterministic.
To determine the destination partition of a set of variables, as part of a move, the oracle chooses the partition that results in the minimum number of variables that need to be moved given the ideal partitioning and the current location of the variables.

\subsection{Performance optimizations}
\label{sec:optm}

In the algorithm presented in the previous section, clients always need to consult the oracle to determine the partition a command must be atomically multicast to for execution.
Obviously, if every command involves the oracle, the system is unlikely to scale, as the oracle will likely become a bottleneck.
To address this issue, clients are equipped with a location cache.
Before submitting a consult request to the oracle, the client checks its location cache.
If the cache contains the partition of the variables needed by the command and all variables are in a single destination partition, the client can atomically multicast the command to the partition and avoid contacting the oracle. 

The client needs to contact the oracle if not all variables needed by the command are in the same partition, or if the cache contains outdated information, or the command is a create, in which case it must involve the oracle, as explained before.
If the cache contains outdated information and the addressed partition does not contain all the variables accessed by the command, the partition tells the client to retry the command.
In this case, the client contacts the oracle and then updates its cache with the oracle's response.

\input{correctness}




